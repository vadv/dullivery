// Code generated by protoc-gen-go.
// source: file.proto
// DO NOT EDIT!

/*
Package ftp is a generated protocol buffer package.

It is generated from these files:
	file.proto

It has these top-level messages:
	Conn
	Info
	Filter
	List
*/
package ftp

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Info_State int32

const (
	Info_OK    Info_State = 0
	Info_ERROR Info_State = 1
)

var Info_State_name = map[int32]string{
	0: "OK",
	1: "ERROR",
}
var Info_State_value = map[string]int32{
	"OK":    0,
	"ERROR": 1,
}

func (x Info_State) String() string {
	return proto.EnumName(Info_State_name, int32(x))
}
func (Info_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type List_State int32

const (
	List_OK    List_State = 0
	List_ERROR List_State = 1
)

var List_State_name = map[int32]string{
	0: "OK",
	1: "ERROR",
}
var List_State_value = map[string]int32{
	"OK":    0,
	"ERROR": 1,
}

func (x List_State) String() string {
	return proto.EnumName(List_State_name, int32(x))
}
func (List_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type Conn struct {
	Host     string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	User     string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
}

func (m *Conn) Reset()                    { *m = Conn{} }
func (m *Conn) String() string            { return proto.CompactTextString(m) }
func (*Conn) ProtoMessage()               {}
func (*Conn) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Conn) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Conn) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Conn) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type Info struct {
	Connection *Conn      `protobuf:"bytes,1,opt,name=connection" json:"connection,omitempty"`
	Path       string     `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	LocalPath  string     `protobuf:"bytes,3,opt,name=local_path,json=localPath" json:"local_path,omitempty"`
	Size       int64      `protobuf:"varint,4,opt,name=size" json:"size,omitempty"`
	ModTime    int64      `protobuf:"varint,5,opt,name=mod_time,json=modTime" json:"mod_time,omitempty"`
	State      Info_State `protobuf:"varint,6,opt,name=state,enum=ftp.Info_State" json:"state,omitempty"`
	Error      string     `protobuf:"bytes,7,opt,name=error" json:"error,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Info) GetConnection() *Conn {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *Info) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Info) GetLocalPath() string {
	if m != nil {
		return m.LocalPath
	}
	return ""
}

func (m *Info) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Info) GetModTime() int64 {
	if m != nil {
		return m.ModTime
	}
	return 0
}

func (m *Info) GetState() Info_State {
	if m != nil {
		return m.State
	}
	return Info_OK
}

func (m *Info) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Filter struct {
	Connection *Conn  `protobuf:"bytes,1,opt,name=connection" json:"connection,omitempty"`
	PathMatch  string `protobuf:"bytes,2,opt,name=path_match,json=pathMatch" json:"path_match,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Filter) GetConnection() *Conn {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *Filter) GetPathMatch() string {
	if m != nil {
		return m.PathMatch
	}
	return ""
}

type List struct {
	Files []*Info    `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
	State List_State `protobuf:"varint,2,opt,name=state,enum=ftp.List_State" json:"state,omitempty"`
	Error string     `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *List) Reset()                    { *m = List{} }
func (m *List) String() string            { return proto.CompactTextString(m) }
func (*List) ProtoMessage()               {}
func (*List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *List) GetFiles() []*Info {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *List) GetState() List_State {
	if m != nil {
		return m.State
	}
	return List_OK
}

func (m *List) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*Conn)(nil), "ftp.Conn")
	proto.RegisterType((*Info)(nil), "ftp.Info")
	proto.RegisterType((*Filter)(nil), "ftp.Filter")
	proto.RegisterType((*List)(nil), "ftp.List")
	proto.RegisterEnum("ftp.Info_State", Info_State_name, Info_State_value)
	proto.RegisterEnum("ftp.List_State", List_State_name, List_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for File service

type FileClient interface {
	Find(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*List, error)
	Download(ctx context.Context, in *Info, opts ...grpc.CallOption) (*Info, error)
	Upload(ctx context.Context, in *Info, opts ...grpc.CallOption) (*Info, error)
	Delete(ctx context.Context, in *Info, opts ...grpc.CallOption) (*Info, error)
}

type fileClient struct {
	cc *grpc.ClientConn
}

func NewFileClient(cc *grpc.ClientConn) FileClient {
	return &fileClient{cc}
}

func (c *fileClient) Find(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*List, error) {
	out := new(List)
	err := grpc.Invoke(ctx, "/ftp.File/Find", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileClient) Download(ctx context.Context, in *Info, opts ...grpc.CallOption) (*Info, error) {
	out := new(Info)
	err := grpc.Invoke(ctx, "/ftp.File/Download", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileClient) Upload(ctx context.Context, in *Info, opts ...grpc.CallOption) (*Info, error) {
	out := new(Info)
	err := grpc.Invoke(ctx, "/ftp.File/Upload", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileClient) Delete(ctx context.Context, in *Info, opts ...grpc.CallOption) (*Info, error) {
	out := new(Info)
	err := grpc.Invoke(ctx, "/ftp.File/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for File service

type FileServer interface {
	Find(context.Context, *Filter) (*List, error)
	Download(context.Context, *Info) (*Info, error)
	Upload(context.Context, *Info) (*Info, error)
	Delete(context.Context, *Info) (*Info, error)
}

func RegisterFileServer(s *grpc.Server, srv FileServer) {
	s.RegisterService(&_File_serviceDesc, srv)
}

func _File_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ftp.File/Find",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServer).Find(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _File_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Info)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ftp.File/Download",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServer).Download(ctx, req.(*Info))
	}
	return interceptor(ctx, in, info, handler)
}

func _File_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Info)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ftp.File/Upload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServer).Upload(ctx, req.(*Info))
	}
	return interceptor(ctx, in, info, handler)
}

func _File_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Info)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ftp.File/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServer).Delete(ctx, req.(*Info))
	}
	return interceptor(ctx, in, info, handler)
}

var _File_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ftp.File",
	HandlerType: (*FileServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Find",
			Handler:    _File_Find_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _File_Download_Handler,
		},
		{
			MethodName: "Upload",
			Handler:    _File_Upload_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _File_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "file.proto",
}

func init() { proto.RegisterFile("file.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 370 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x52, 0xcd, 0x4a, 0xc3, 0x40,
	0x10, 0x6e, 0x9a, 0x9f, 0x36, 0x53, 0xd0, 0x32, 0x78, 0x88, 0x01, 0xb1, 0x04, 0x04, 0xbd, 0xe4,
	0x50, 0x1f, 0xc1, 0x2a, 0xf8, 0x47, 0x65, 0xd5, 0x73, 0x89, 0xc9, 0x96, 0x06, 0xd2, 0x6c, 0x48,
	0x56, 0x0a, 0x9e, 0x7c, 0x04, 0x1f, 0xd4, 0x87, 0x70, 0x66, 0x43, 0x7f, 0x2e, 0x45, 0x3d, 0x75,
	0xe6, 0x9b, 0xd9, 0xef, 0x67, 0x1a, 0x80, 0x79, 0x5e, 0xc8, 0xb8, 0xaa, 0x95, 0x56, 0x68, 0xcf,
	0x75, 0x15, 0xdd, 0x81, 0x73, 0xa5, 0xca, 0x12, 0x11, 0x9c, 0x85, 0x6a, 0x74, 0x60, 0x8d, 0xac,
	0x73, 0x5f, 0x98, 0x9a, 0xb1, 0xf7, 0x46, 0xd6, 0x41, 0xb7, 0xc5, 0xb8, 0xc6, 0x10, 0xfa, 0x55,
	0xd2, 0x34, 0x2b, 0x55, 0x67, 0x81, 0x6d, 0xf0, 0x4d, 0x1f, 0x7d, 0x5b, 0xe0, 0xdc, 0x96, 0x73,
	0x85, 0x17, 0x00, 0x29, 0x91, 0xca, 0x54, 0xe7, 0xaa, 0x34, 0x94, 0x83, 0xb1, 0x1f, 0x93, 0x5c,
	0xcc, 0x5a, 0x62, 0x67, 0xc8, 0x1a, 0x55, 0xa2, 0x17, 0x6b, 0x0d, 0xae, 0xf1, 0x04, 0xa0, 0x50,
	0x69, 0x52, 0xcc, 0xcc, 0xa4, 0x55, 0xf1, 0x0d, 0xf2, 0xc4, 0x63, 0x7a, 0xd2, 0xe4, 0x1f, 0x32,
	0x70, 0x68, 0x60, 0x0b, 0x53, 0xe3, 0x31, 0xf4, 0x97, 0x2a, 0x9b, 0xe9, 0x7c, 0x29, 0x03, 0xd7,
	0xe0, 0x3d, 0xea, 0x5f, 0xa8, 0xc5, 0x33, 0x70, 0x1b, 0x9d, 0x68, 0x19, 0x78, 0x84, 0x1f, 0x8c,
	0x0f, 0x8d, 0x0f, 0xb6, 0x19, 0x3f, 0x33, 0x2c, 0xda, 0x29, 0x1e, 0x81, 0x2b, 0xeb, 0x5a, 0xd5,
	0x41, 0xcf, 0xe8, 0xb5, 0x4d, 0x14, 0x82, 0x6b, 0xb6, 0xd0, 0x83, 0xee, 0xf4, 0x7e, 0xd8, 0x41,
	0x1f, 0xdc, 0x6b, 0x21, 0xa6, 0x62, 0x68, 0x45, 0x02, 0xbc, 0x9b, 0xbc, 0xd0, 0x74, 0x94, 0x7f,
	0xe4, 0xa5, 0x6c, 0x9c, 0x6a, 0xb6, 0x4c, 0x74, 0xba, 0x4e, 0xed, 0x33, 0xf2, 0xc8, 0x40, 0xf4,
	0x49, 0x27, 0x7c, 0xc8, 0xe9, 0xf6, 0xa7, 0xe0, 0xf2, 0x5f, 0xd5, 0x10, 0x9b, 0xbd, 0x61, 0x63,
	0xd7, 0xa2, 0xc5, 0xb7, 0xb1, 0xba, 0x3b, 0xb1, 0xf8, 0xe9, 0x9e, 0x58, 0xf6, 0x1f, 0x63, 0x8d,
	0xbf, 0xc8, 0x02, 0xe5, 0x92, 0x38, 0xe2, 0xdf, 0x32, 0xc3, 0x81, 0xa1, 0x6e, 0xa3, 0x86, 0xfe,
	0x46, 0x27, 0xea, 0x60, 0x04, 0xfd, 0x89, 0x5a, 0x95, 0x85, 0x4a, 0x32, 0xdc, 0x3a, 0x0c, 0xb7,
	0x25, 0xed, 0x8c, 0xc0, 0x7b, 0xad, 0x7e, 0xdb, 0x98, 0xc8, 0x42, 0x92, 0x9b, 0x3d, 0x1b, 0x6f,
	0x9e, 0xf9, 0x60, 0x2f, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xd3, 0xea, 0xe1, 0xa1, 0xbe, 0x02,
	0x00, 0x00,
}
